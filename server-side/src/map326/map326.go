/*
An in-memory key/value map where keys are 32 bytes and values are 6 bytes.
Keys are assumed to be generated by a high quality pseudo random function such as SHA256.

This implementation attempts to minimize RAM usage at a slight cost of speed.  The goal is to
store ~30 million keys per 1GB of RAM.  Usage of Go's heap is minimized to avoid
the significant per-allocation overhead and garbage collector load.
*/
package map326

import (
	"fixedpool"
	"errors"
	"util"
	"bytes"
	//"fmt"
)

const KeySize = 32

/*
Entry format:
	Next Entry Pointer (4 bytes)
	Key Suffix (30 bytes)
	Value (6 bytes)
*/
const entrySize = 40

//65,536 (16bits)
const nRegions = 0x10000

//a fake Ptr value which marks the head bucket at used.
const ptrSolo = fixedpool.Ptr(0xFFFFFFFF)

const (
	putOutOfMemory = 0
	putKeyWasNew = 1
	putValueUpdated = 2
)

type Map struct {
	/*
	This holds 65,536 logical regions.  Each region is a hashmap
	of with 'epr' buckets.  Each bucket is 38 bytes (see entrySize
	comment for details).  For a given key, the region is selected
	by the first 16bits of the key.  This saves 2 bytes per entry.
	*/
	data []byte
	//number of key/value entries per region
	epr int
	//the current number of key/value entries which are used.
	numEntries int
	//buckets with more than one occupant are allocated from here
	pool *fixedpool.Pool
}

/*
A six byte array.
*/
type Value [6]byte

type _Region struct {
	data []byte
	//number of key/value entries per region
	epr int
}

/*
Entry format:
	Next Entry Pointer (4 bytes)
	Key Suffix (30 bytes)
	Value (4 bytes)
*/
type _Entry []byte


func ValueFromInt(val int) (dest Value) {
	//big-endian
	dest[0] = byte((val >> 24) & 0xFF)
	dest[1] = byte((val >> 16) & 0xFF)
	dest[2] = byte((val >> 8) & 0xFF)
	dest[3] = byte(val & 0xFF)
	return
}

func ValueToInt(v Value) int {
	//big endian
	return ((int(v[0]) & 0xFF) << 24) |
		(int(v[1]) << 16) |
		(int(v[2]) << 8) |
		int(v[3])
}

func New(maxNumEntries int) (*Map, error) {
	if maxNumEntries <= 0 {
		return nil, errors.New("maxNumEntries too small")
	}

	// To save memory we will underallocate the hashmap by a factor of 4.
	//This reduces the number of unused buckets at the cost of longer chains
	// per bucket.  In my experiments, a map with 16,000,000 entries resulted in:
	//
	//  72858 buckets had 0 occupants (1.8224998%)
	//  292184 buckets had 1 occupants (7.3088098%)
	//  585626 buckets had 2 occupants (14.649088%)
	//  779624 buckets had 3 occupants (19.501833%)
	//  782231 buckets had 4 occupants (19.567047%)
	//  625585 buckets had 5 occupants (15.648639%)
	//  416656 buckets had 6 occupants (10.422403%)
	//  237710 buckets had 7 occupants (5.946175%)
	//  119306 buckets had 8 occupants (2.984369%)
	//  53289 buckets had 9 occupants (1.3329928%)
	//  21217 buckets had 10 occupants (0.5307307%)
	//  7707 buckets had 11 occupants (0.19278604%)
	//  2605 buckets had 12 occupants (0.06516253%)
	//  803 buckets had 13 occupants (0.02008657%)
	//  213 buckets had 14 occupants (0.005328069%)
	//  57 buckets had 15 occupants (0.0014258212%)
	//  21 buckets had 16 occupants (0.0005253026%)
	//  3 buckets had 17 occupants (7.504322e-05%)
	//  1 buckets had 18 occupants (2.5014408e-05%)

	//calc entries per region.
	epr := maxNumEntries / nRegions / 4
	if epr < 1 {
		epr = 1
	}

	nBytes := uint64(epr) * nRegions * entrySize

	//check for int overflow
	if uint64(int(nBytes)) != nBytes {
		return nil, errors.New("allocation too large for signed int")
	}

	//Buckets with more than one occupant are allocated from a fixedpool.
	//When this pool is exhausted we should be close to maxNumEntries (statistically).
	entriesInMainTable := epr * nRegions
	poolSize := maxNumEntries - entriesInMainTable
	if poolSize < 10 {
		poolSize = 10
	}

	return &Map{
		data: make([]byte, int(nBytes)),
		epr: epr,
		pool: fixedpool.NewPool(entrySize, poolSize),
	}, nil
}

//16bit integer big-endian from bytes
func uint16FromBytes(v []byte) int {
	return (int(v[0]) << 8) | int(v[1])
}

func (m *Map) getRegionForKey(key []byte) _Region {
	regionIndex := uint16FromBytes(key)
	bytesPerRegion := m.epr * entrySize
	offs := regionIndex * bytesPerRegion
	return _Region{
		data: m.data[offs: offs+bytesPerRegion],
		epr: m.epr,
	}
}

func (m *Map) getPoolBucket(ptr fixedpool.Ptr) _Entry {
	return _Entry(m.pool.Get(ptr))
}


/*
Add or update a key/value entry.
Returns 1 if the key did not yet exist in the map,
2 if the key existed, 0 if the map is full.
*/
func (m *Map) Put(key []byte, value Value) int {
	if len(key) != KeySize {
		panic("wrong key size")
	}

	reg := m.getRegionForKey(key)
	keySuffix := key[2:]

	//use the next 16bits as the hashcode
	bucketIndex := uint16FromBytes(keySuffix) % m.epr

	headBucket := reg.getBucket(bucketIndex)

	next := headBucket.getPtr()
	if next == fixedpool.Zero {
		//headBucket is empty.  Use it.
		headBucket.setPtr(ptrSolo)
		headBucket.setKeyValue(keySuffix, value)
		return putKeyWasNew
	} else if headBucket.cmpKeySuffix(keySuffix) == 0 {
		//key already present.  Just update the value
		headBucket.setValue(value)
		return putValueUpdated
	}

	prevBucket := headBucket

	if next == ptrSolo {
		//chain size is one
		next = fixedpool.Zero
	} else {
		//Search the chain...
		for next != fixedpool.Zero {
			bucket := m.getPoolBucket(next)

			cmp := bucket.cmpKeySuffix(keySuffix)
			if cmp == 0 {
				//key already present.  Just update the value
				bucket.setValue(value)
				return putValueUpdated
			} else if cmp > 0 {
				//incoming key is lesser - insert it here
				break
			} //else incoming is greater

			next = bucket.getPtr()
			prevBucket = bucket
		}
	}

	//
	// Insert a new node after prevBucket

	ptr := m.pool.Alloc()
	if ptr == fixedpool.Zero {
		return putOutOfMemory
	}
	newBucket := _Entry(m.pool.Get(ptr))
	newBucket.setPtr(next)
	newBucket.setKeyValue(keySuffix, value)
	prevBucket.setPtr(ptr)
	return putKeyWasNew
}

/*
Lookup a value from the map.  Returns false if not found.
*/
func (m *Map) Get(key []byte) (value Value, found bool) {
	if len(key) != KeySize {
		panic("wrong key size")
	}


	reg := m.getRegionForKey(key)
	keySuffix := key[2:]

	//use the next 16bits as the hashcode
	bucketIndex := uint16FromBytes(keySuffix) % m.epr

	headBucket := reg.getBucket(bucketIndex)
	next := headBucket.getPtr()
	if next == fixedpool.Zero {
		//empty bucket
		return
	} else if headBucket.cmpKeySuffix(keySuffix) == 0 {
		found = true
		value = headBucket.getValue()
		return
	} else if next == ptrSolo {
		//there was only one
		return
	}

	//Search the chain...
	for next != fixedpool.Zero {
		bucket := m.getPoolBucket(next)

		cmp := bucket.cmpKeySuffix(keySuffix)
		if cmp == 0 {
			found = true
			value = bucket.getValue()
			return
		} else if cmp > 0 {
			//query key is lesser - halt search
			return
		}

		next = bucket.getPtr()
	}

	//not found
	return

/*
	reg := m.getRegionForKey(key)
	keySuffix := key[2:]

	//use the next 16bits as the hashcode
	bucketIndex := uint16FromBytes(keySuffix) % m.epr

	bucket := reg.getBucket(bucketIndex)
	next := bucket.getPtr()
	if next == fixedpool.Zero {
		//empty bucket
		return
	}

	//Search the chain...
	for {
		if bucket.sameKeySuffix(keySuffix) {
			found = true
			value = bucket.getValue()
			return
		}

		next = bucket.getPtr()
		if next == fixedpool.Zero || next == ptrSolo {
			//end of chain
			return
		}

		bucket = m.getPoolBucket(next)
	}

	return*/
}

func (reg _Region) getBucket(index int) _Entry {
	offset := index * entrySize
	return _Entry(reg.data[offset:offset+entrySize])
}

func (e _Entry) getPtr() fixedpool.Ptr {
	//first 4 bytes
	return fixedpool.Ptr(util.Uint32FromBytes(e))
}

func (e _Entry) setPtr(ptr fixedpool.Ptr) {
	util.Uint32ToBytes(uint32(ptr), e)
}

func (e _Entry) setKeyValue(keySuffix []byte, value Value) {
	copy(e[4:34], keySuffix)
	copy(e[34:40], value[:])
}

func (e _Entry) setValue(value Value) {
	copy(e[34:40], value[:])
}

func (e _Entry) getValue() (value Value) {
	copy(value[:], e[34:40])
	return
}

func (e _Entry) cmpKeySuffix(keySuffix []byte) int {
	return bytes.Compare(e[4:34], keySuffix)
}

func (e _Entry) sameKeySuffix(keySuffix []byte) bool {
	return bytes.Equal(e[4:34], keySuffix)
}
