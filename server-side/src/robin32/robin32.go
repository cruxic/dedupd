/*
An in-memory key/value store where keys are 32 bytes and values are fixed-size bytes.
Keys are assumed to be generated by a high quality pseudo random function such as SHA256.

The goal is to implement a map which can hold tens of millions of entries with minmal memory waste.
Usage of Go's heap is minimized to avoid the significant per-allocation overhead and garbage collector load.

This implementaion uses "Robin Hood" hashing to improve cache locality and density.  It also uses a dedicated memory pool for
the value data.  Pointers from this pool are 32bits instead of 64.
*/
package robin32

//Good guides to Robin Hood hashing:
//  https://www.sebastiansylvan.com/post/robin-hood-hashing-should-be-your-default-hash-table-implementation/
//
//  http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/

import (
	"fixedpool"
	"math"
	"encoding/binary"
	"bytes"
)


//32 bytes
const KeySize = 32

//number of key bytes stored alongside the value.
//The first 4 key bytes are stored in the bucket. This is the remainder.
const keySuffixLen = 28

type PutResult int
const (
	//New entry was added.
	PRKeyWasNew PutResult = 1
	//Updated value of an existing entry.
	PRValueUpdated PutResult = 2
	//Map is has reached maximum capacity.
	PRFull PutResult = -1
	//key or value was wrong size.
	PRIllegalArg PutResult = -2
	//Internal assertion failure
	PRAssertFail PutResult = -3
)

//True if the Put() succeeded.
func (pr PutResult) OK() bool {
	return pr > 0
}


/*
Each bucket is 8 bytes.
*/
type _Bucket struct {
	//The first 4 bytes of the key as a little endian integer.
	KeyPrefix uint32
	//Pointer to the remainder of the key and it's value.
	More fixedpool.Ptr
}

type Map struct {
	buckets []_Bucket

	//holds the key suffix and value for each entry
	pool *fixedpool.Pool

	//Current number of occupied buckets
	nOccupied int

	//Max number of occupied buckets.
	// This is usually 15% less than the number of buckets in the region.
	maxOccupied int

	//The size of each value, in bytes
	valueSize int
}

func NewMap(maxCapacity int, valueSize int) *Map {
	if maxCapacity < 10 {
		maxCapacity = 10
	}
	if valueSize <= 0 {
		panic("illegal valueSize")
	}

	//Allocate 15% more buckets.  Robin hood hashing keeps
	// probe distance reasonable until about 85-90% capacity
	nBuckets := int(math.Ceil(float64(maxCapacity) * 1.15))

	return &Map{
		buckets: make([]_Bucket, nBuckets),
		maxOccupied: maxCapacity,
		valueSize: valueSize,
		pool: fixedpool.NewPool(keySuffixLen + valueSize, maxCapacity),
	}
}

//Hash the first 32bits of the key to an index
func (m *Map) index(keyPrefix uint32) int {
	len32 := uint32(len(m.buckets))
	return int(keyPrefix % len32)
}

func keyPrefixAsUint32(key []byte) uint32 {
	return binary.LittleEndian.Uint32(key)
}

func (m *Map) probeDist(b _Bucket, currentIndex int) int {
	desiredIndex := m.index(b.KeyPrefix)
	if currentIndex < desiredIndex {
		//wrapped due to modulo
		return len(m.buckets) - desiredIndex + currentIndex
	} else {
		return currentIndex - desiredIndex
	}
}

func (b _Bucket) isEmpty() bool {
	return b.More == fixedpool.Zero
}

func (m *Map) allocBucket(key []byte, value []byte) (_Bucket, bool) {
	b := _Bucket{
		KeyPrefix: keyPrefixAsUint32(key),
		More: m.pool.Alloc(),
	}

	if b.More == fixedpool.Zero {
		//alloc failed
		return b, false
	}

	//copy key suffix and value into pool block
	dat := m.pool.Get(b.More)
	copy(dat, key[4:])
	copy(dat[keySuffixLen:], value)

	return b, true
}

func (m *Map) freeBucket(b *_Bucket) {
	m.pool.Free(b.More)
	b.More = fixedpool.Zero
}

func (m *Map) isKeyEqual(a, b _Bucket) bool {
	if a.KeyPrefix == b.KeyPrefix {
		aMore := m.pool.Get(a.More)
		bMore := m.pool.Get(b.More)
		return bytes.Equal(aMore[0:keySuffixLen], bMore[0:keySuffixLen])
	} else {
		return false
	}
}

func (m *Map) isKeyEqual2(a _Bucket, bKeyPrefix uint32, bKeySuffix []byte) bool {
	if a.KeyPrefix == bKeyPrefix {
		aMore := m.pool.Get(a.More)
		return bytes.Equal(aMore[0:keySuffixLen], bKeySuffix)
	} else {
		return false
	}
}


//Copy the bucket value from src to dest
func (m *Map) copyValue(src, dest _Bucket) {
	srcMore := m.pool.Get(src.More)
	destMore := m.pool.Get(dest.More)
	copy(destMore[keySuffixLen:], srcMore[keySuffixLen:])
}

func (m *Map) getValueRef(bucket _Bucket) []byte {
	return m.pool.Get(bucket.More)[keySuffixLen:]
}

func (m *Map) Put(key []byte, value []byte) PutResult {
	if len(key) != KeySize {
		return PRIllegalArg
	}
	if len(value) != m.valueSize {
		return PRIllegalArg
	}

	if m.nOccupied >= m.maxOccupied {
		return PRFull
	}

	incoming, ok := m.allocBucket(key, value)
	if !ok {
		//should not happen because pool was allocated to hold maxOccupied
		return PRAssertFail
	}

	idx := m.index(incoming.KeyPrefix)
	dist := 0
	wrapped := false

	for {
		other := m.buckets[idx]

		if other.isEmpty() {
			//Use empty bucket
			m.nOccupied++
			m.buckets[idx] = incoming
			return PRKeyWasNew
		} else if m.isKeyEqual(incoming, other) {
			//Update existing
			m.copyValue(incoming, m.buckets[idx])
			m.freeBucket(&incoming)
			return PRValueUpdated
		}

		otherDist := m.probeDist(other, idx)
		if otherDist < dist {
			//Rob from the rich and give to the poor!
			m.buckets[idx] = incoming
			incoming = other
			dist = otherDist
		}

		dist++
		idx++

		//wrap around
		if idx >= len(m.buckets) {
			idx = 0
			if wrapped {
				//will not happen because we disallow Put when nOccupied >= maxOccupied
				panic("Put failed to terminate")
			}
			wrapped = true
		}
	}
}

func (m *Map) Get(key []byte, resultValue []byte) bool {
	//sanity
	if len(key) != KeySize {
		return false
	} else if len(resultValue) != m.valueSize {
		panic("resultValue wrong size")
	}

	keyPrefix := keyPrefixAsUint32(key)
	keySuffix := key[4:]
	idx := m.index(keyPrefix)
	dist := 0
	wrapped := false

	for {
		other := m.buckets[idx]

		if other.isEmpty() {
			//not found
			return false
		} else if m.isKeyEqual2(other, keyPrefix, keySuffix) {
			//Found!
			copy(resultValue, m.getValueRef(other))
			return true
		}

		otherDist := m.probeDist(other, idx)
		if otherDist < dist {
			//not found
			return false
		}

		dist++
		idx++
		if idx >= len(m.buckets) {
			if wrapped {
				//not found
				return false
			}
			idx = 0
			wrapped = true
		}
	}
}
